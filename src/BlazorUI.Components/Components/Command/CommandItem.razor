@namespace BlazorUI.Components.Command
@using BlazorUI.Components.Utilities
@implements IDisposable
@inject IJSRuntime JS

@* CommandItem - selectable item in the command list *@
@if (_isVisible)
{
    <div id="@_itemId"
         role="option"
         aria-selected="@(_isFocused ? "true" : "false")"
         aria-disabled="@(Disabled ? "true" : "false")"
         data-focused="@(_isFocused ? "true" : "false")"
         data-disabled="@(Disabled ? "true" : "false")"
         @onclick="HandleClick"
         @onmouseenter="HandleMouseEnter"
         class="@CssClass">
        @ChildContent
    </div>
}

@code {
    [CascadingParameter]
    public CommandContext? Context { get; set; }

    [CascadingParameter(Name = "CommandGroupId")]
    public string? GroupId { get; set; }

    /// <summary>
    /// Gets or sets additional CSS classes to apply to the item.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Gets or sets the content to be rendered inside the item.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets the value associated with this item.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Gets or sets whether this item is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when this item is selected.
    /// </summary>
    [Parameter]
    public EventCallback OnSelect { get; set; }

    /// <summary>
    /// Gets or sets the text used for search filtering. If not provided, uses Value.
    /// </summary>
    [Parameter]
    public string? SearchText { get; set; }

    private int _index = -1;
    private int _filteredIndex = -1;
    private string _itemId = string.Empty;
    private bool _isFocused;
    private bool _isVisible = true;
    private bool _shouldScrollIntoView;

    /// <summary>
    /// Gets the computed CSS classes for the item.
    /// </summary>
    private string CssClass => ClassNames.cn(
        "relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none",
        !Disabled ? "hover:bg-accent hover:text-accent-foreground" : null,
        Disabled ? "opacity-50 cursor-not-allowed" : null,
        _isFocused ? "bg-accent text-accent-foreground" : null,
        Class
    );

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException($"{nameof(CommandItem)} must be used within a {nameof(Command)} component.");
        }

        // Register with context
        _index = Context.RegisterItem(
            value: Value,
            searchText: SearchText ?? Value ?? string.Empty,
            disabled: Disabled,
            onSelect: OnSelect,
            groupId: GroupId
        );

        _itemId = Context.GetItemId(_index);

        // Subscribe to targeted events for better performance
        Context.OnFocusChanged += HandleFocusChanged;
        Context.OnSearchChanged += HandleSearchChanged;

        // Initial visibility check
        UpdateVisibilityAndFilteredIndex();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Update registration when parameters change
        if (_index >= 0 && Context != null)
        {
            Context.UpdateItem(
                index: _index,
                value: Value,
                searchText: SearchText ?? Value ?? string.Empty,
                disabled: Disabled,
                onSelect: OnSelect,
                groupId: GroupId
            );
        }
    }

    private async Task HandleClick()
    {
        if (Disabled || Context == null) return;

        await Context.SelectItemByValueAsync(Value ?? string.Empty);
    }

    private void HandleMouseEnter()
    {
        if (Disabled || Context == null || !_isVisible) return;

        // Use cached filtered index if available, otherwise calculate it
        if (_filteredIndex >= 0)
        {
            Context.SetFocusedIndex(_filteredIndex);
        }
    }

    private void HandleFocusChanged(int previousIndex, int newIndex)
    {
        // Only re-render if this item is affected by the focus change
        if (_filteredIndex == previousIndex || _filteredIndex == newIndex)
        {
            var wasFocused = _isFocused;
            _isFocused = _filteredIndex == newIndex;

            // Scroll into view when becoming focused (keyboard navigation)
            if (_isFocused && !wasFocused)
            {
                _shouldScrollIntoView = true;
            }

            StateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScrollIntoView && _isFocused)
        {
            _shouldScrollIntoView = false;
            try
            {
                // Use 'start' for first item to show group heading, 'nearest' for others
                var scrollBlock = _filteredIndex == 0 ? "start" : "nearest";
                await JS.InvokeVoidAsync("eval", $"document.getElementById('{_itemId}')?.scrollIntoView({{block: '{scrollBlock}', behavior: 'instant'}})");
            }
            catch
            {
                // Ignore JS errors during scroll
            }
        }
    }

    private void HandleSearchChanged()
    {
        // Update visibility and filtered index when search changes
        UpdateVisibilityAndFilteredIndex();

        // Reset focused state since search changed
        _isFocused = false;

        StateHasChanged();
    }

    private void UpdateVisibilityAndFilteredIndex()
    {
        if (Context == null)
        {
            _isVisible = false;
            _filteredIndex = -1;
            return;
        }

        var thisItem = Context.GetItemByIndex(_index);
        if (thisItem == null)
        {
            _isVisible = false;
            _filteredIndex = -1;
            return;
        }

        // Check if item passes filter
        if (string.IsNullOrWhiteSpace(Context.SearchQuery))
        {
            _isVisible = true;
        }
        else if (Context.FilterFunction != null)
        {
            _isVisible = Context.FilterFunction(thisItem, Context.SearchQuery);
        }
        else
        {
            _isVisible = thisItem.SearchText?.Contains(Context.SearchQuery, StringComparison.OrdinalIgnoreCase) ?? false;
        }

        // Update filtered index for efficient focus handling
        if (_isVisible)
        {
            var filteredItems = Context.GetFilteredItems();
            _filteredIndex = filteredItems.IndexOf(thisItem);
        }
        else
        {
            _filteredIndex = -1;
        }
    }

    public void Dispose()
    {
        if (Context != null && _index >= 0)
        {
            Context.UnregisterItem(_index);
            Context.OnFocusChanged -= HandleFocusChanged;
            Context.OnSearchChanged -= HandleSearchChanged;
        }
    }
}
